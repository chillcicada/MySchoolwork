import{_ as i,b as a,a9 as e,o as s}from"./chunks/framework.BjzsCNOl.js";const g=JSON.parse('{"title":"Fortran 程序设计基础","description":"","frontmatter":{},"headers":[],"relativePath":"面向科学计算的Fortran程序设计/第四讲-Fortran程序设计基础.md","filePath":"面向科学计算的Fortran程序设计/第四讲-Fortran程序设计基础.md","lastUpdated":1738393782000}'),l={name:"面向科学计算的Fortran程序设计/第四讲-Fortran程序设计基础.md"};function n(r,t,h,d,k,p){return s(),a("div",null,t[0]||(t[0]=[e(`<h1 id="fortran-程序设计基础" tabindex="-1">Fortran 程序设计基础 <a class="header-anchor" href="#fortran-程序设计基础" aria-label="Permalink to &quot;Fortran 程序设计基础&quot;">​</a></h1><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to &quot;目录&quot;">​</a></h2><ul><li><a href="#fortran-程序设计基础">Fortran 程序设计基础</a><ul><li><a href="#目录">目录</a></li><li><a href="#字符集">字符集</a></li><li><a href="#书面格式">书面格式</a><ul><li><a href="#固定格式">固定格式</a></li><li><a href="#自由格式">自由格式</a></li></ul></li><li><a href="#数据类型声明">数据类型声明</a><ul><li><a href="#整数-integer-类型">整数 (integer) 类型</a></li><li><a href="#浮点数-real-类型">浮点数 (real) 类型</a></li><li><a href="#逻辑-logical-类型">逻辑 (logical) 类型</a></li><li><a href="#字符-character-类型">字符 (character) 类型</a></li></ul></li><li><a href="#数学表达式">数学表达式</a><ul><li><a href="#混合精度计算">混合精度计算</a></li></ul></li></ul></li></ul><h2 id="字符集" tabindex="-1">字符集 <a class="header-anchor" href="#字符集" aria-label="Permalink to &quot;字符集&quot;">​</a></h2><p>字符集：指编写 Fortran 程序时，所能使用的所有字符及符号</p><table tabindex="0"><thead><tr><th style="text-align:center;">字符集类型</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">英文 26 个字母</td><td style="text-align:center;">A-Z 及 a-z</td></tr><tr><td style="text-align:center;">数字</td><td style="text-align:center;">0-9</td></tr><tr><td style="text-align:center;">22 个特殊符号</td><td style="text-align:center;">:=+-*/(),.&#39;!&quot;%&amp;;&lt;&gt;?$_ (空格)</td></tr></tbody></table><p>Fortran 不区分命令中字母的大小写，<strong>命令中的所有大写英文字母都会被视同为小写字母</strong>。INTEGER, integer, Integer, InteGer, INTEGEr 都是同一个命令</p><blockquote><p>C/C++ 是区分大小写的编程语言，在 C 程序中调用 Fortran 或在 Fortran 中调用 C 时，需要注意大小写问题</p></blockquote><h2 id="书面格式" tabindex="-1">书面格式 <a class="header-anchor" href="#书面格式" aria-label="Permalink to &quot;书面格式&quot;">​</a></h2><p>书面格式：指 Fortran 程序代码的编写格式，包括固定格式（Fixed Format）和自由格式（Free Format）</p><table tabindex="0"><thead><tr><th style="text-align:center;">书面格式</th><th style="text-align:center;">程序文件名</th><th style="text-align:center;">Fortran 标准</th></tr></thead><tbody><tr><td style="text-align:center;">固定格式</td><td style="text-align:center;">_.f; _.F; _.for; _.FOR</td><td style="text-align:center;">Fortran 77</td></tr><tr><td style="text-align:center;">自由格式</td><td style="text-align:center;">_.f90; _.F90; _.f95; _.F95</td><td style="text-align:center;">Fortran 90/95</td></tr></tbody></table><p>编译器根据程序文件名的后缀，自动确定改文件的编写格式</p><h3 id="固定格式" tabindex="-1">固定格式 <a class="header-anchor" href="#固定格式" aria-label="Permalink to &quot;固定格式&quot;">​</a></h3><ul><li>每行最多 72 个字符，每一行中，前 6 个字段为非执行字段，第 7-72 个字符是可以用来编写程序的字段</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">字符位置</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">第 1 个字符</td><td style="text-align:center;">如果是字母 C、c 或星号 *，这一行文本会被当成说明批注，不会被编译</td></tr><tr><td style="text-align:center;">第 1-5 个字符</td><td style="text-align:center;">如果是数字，则是用来给这一行程序代码取个代号。不然只能是空格</td></tr><tr><td style="text-align:center;">第 6 个字符</td><td style="text-align:center;">如果是 “0” 以外的任何字符，则是续行符，表示这一行会接续上一行</td></tr><tr><td style="text-align:center;">第 7-72 个字符</td><td style="text-align:center;">Fortran 程序代码的编写区域</td></tr><tr><td style="text-align:center;">第 73 个字符及之后</td><td style="text-align:center;">不使用，编译时被忽略，可能导致编译错误信息</td></tr></tbody></table><ul><li>感叹号 “!” 以后的字符会被当做注解</li></ul><blockquote><p>vi 编辑器可提示不符合固定格式</p></blockquote><h3 id="自由格式" tabindex="-1">自由格式 <a class="header-anchor" href="#自由格式" aria-label="Permalink to &quot;自由格式&quot;">​</a></h3><ul><li>非常自由的编写格式，没有规定每一行的第几个字符有什么作用</li><li>注意事项： <ul><li>感叹号 “!” 后的文本都是注解</li><li>每行可以编辑 132 个字符 <ul><li>Intel 编译器支持每行无限字符数而 gfortran 仅支持 132 字符数。建议按照 gfortran 标准编写程序</li></ul></li><li>代号放在每行最前面，代号由不超过 5 个数字组成</li><li>续行符为 “&amp;”：当前行要接续下一行时，当前行最后一个字符需要是 “&amp;”；“&amp;” 不能是一行的第一个字符</li></ul></li></ul><h2 id="数据类型声明" tabindex="-1">数据类型声明 <a class="header-anchor" href="#数据类型声明" aria-label="Permalink to &quot;数据类型声明&quot;">​</a></h2><h3 id="整数-integer-类型" tabindex="-1">整数 (integer) 类型 <a class="header-anchor" href="#整数-integer-类型" aria-label="Permalink to &quot;整数 (integer) 类型&quot;">​</a></h3><ul><li>Fortran 支持多种位宽的整数类型，位宽包括 1 字节（8 个 bit）、2 字节、 4 字节、8 字节，不同位宽对应着不同的数值范围。 <ul><li>例如：4 字节位宽对应的数值范围为 -2147483648~2147483647，约-2^32~2^32</li></ul></li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">整数位宽</th><th style="text-align:center;">Fortran 声明方式</th><th style="text-align:center;">C/C++ 声明方式</th></tr></thead><tbody><tr><td style="text-align:center;">1 字节</td><td style="text-align:center;">integer*1; integer(kind=1)</td><td style="text-align:center;">char</td></tr><tr><td style="text-align:center;">2 字节</td><td style="text-align:center;">integer*2; integer(kind=2)</td><td style="text-align:center;">short</td></tr><tr><td style="text-align:center;">4 字节</td><td style="text-align:center;">integer*4; integer(kind=4)</td><td style="text-align:center;">int</td></tr><tr><td style="text-align:center;">8 字节</td><td style="text-align:center;">integer*8; integer(kind=8)</td><td style="text-align:center;">long</td></tr></tbody></table><ul><li>当采用 integer 声明整数变量时，通常位宽默认为 4 字节，但可通过编译选项改变默认位宽 <ul><li>GNU 编译器中把 integer 类型声明默认位宽设为 8 字节的编译选项为 <code>-fdefault-integer-8</code>；GNU 编译器不支持 2 字节位宽，例如：<code>gfortran -fdefault-integer-8</code></li><li>Intel 编译器中控制 integer 类型声明默认位宽(2、4、8字节)的编译选项： <ul><li><code>-i{2|4|8}</code> 设置字节长度，例如：<code>ifort -i8</code></li><li><code>-integer-size &lt;size&gt;</code> 设置位宽，包括 16、32、64，可设置为 64 位(8 字节)</li></ul></li></ul></li><li>将整数位宽写成参数形式，位宽参数可以直接赋值或用 <code>selected_int_kind</code> 来设置 <ul><li><code>selected_int_kind(8)</code> 表示 8 位最大的 10 进制数对应的整数类型，实际上是 4 字节整数</li><li><code>selected_int_kind(10)</code> 表示 8 字节整数</li></ul></li><li>设计整数不同位宽的意义 <ul><li>整数位宽应该足够，以避免错误的溢出</li><li>在位宽足够的情况下，越小的位宽意味着越少的存储空间需求、访存带宽用量和 I/O 带宽用量，意味着更快的计算速度</li><li>在过去，不同位宽的整数计算的指令开销不同</li></ul></li><li>GCC (<strong>新版</strong>)可支持位宽为16字节整数，但 Intel 编译器还不支持 <ul><li>大多数处理器指令至多能运算 8 字节整数，16 字节整数只能用程序模拟执行，因此计算速度慢</li></ul></li></ul><h3 id="浮点数-real-类型" tabindex="-1">浮点数 (real) 类型 <a class="header-anchor" href="#浮点数-real-类型" aria-label="Permalink to &quot;浮点数 (real) 类型&quot;">​</a></h3><ul><li>Fortran 支持三种位宽的浮点数类型，位宽包括 4 字节、8 字节、16 字节，不同位宽对应着不同的数值范围和有效数位。</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">精度</th><th style="text-align:center;">正数取值范围</th><th style="text-align:center;">负数取值范围</th></tr></thead><tbody><tr><td style="text-align:center;">单精度类型</td><td style="text-align:center;">1.4e-45 至 3.4e+38</td><td style="text-align:center;">-3.4e+38 至 -1.4e-45</td></tr><tr><td style="text-align:center;">双精度类型</td><td style="text-align:center;">4.9e-324 至 1.798e+308</td><td style="text-align:center;">-1.798e+308 至 -4.9e-324</td></tr></tbody></table><table tabindex="0"><thead><tr><th style="text-align:center;">浮点数位宽</th><th style="text-align:center;">Fortran 声明方式</th><th style="text-align:center;">C/C++ 声明方式</th></tr></thead><tbody><tr><td style="text-align:center;">4 字节</td><td style="text-align:center;">real*4; real(kind=4)</td><td style="text-align:center;">float</td></tr><tr><td style="text-align:center;">8 字节</td><td style="text-align:center;">real*8; real(kind=8)</td><td style="text-align:center;">double</td></tr><tr><td style="text-align:center;">16 字节</td><td style="text-align:center;">real*16; real(kind=16)</td><td style="text-align:center;">long double</td></tr></tbody></table><ul><li>早期编译器版本可能不支持 16 字节浮点数</li><li>大多数处理器指令至多能运算 8 字节浮点数，16 字节浮点数只能用程序模拟执行，因此计算速度很慢，特别是除法</li><li>当采用 real 声明整数变量时，通常位宽默认为 4 字节，但可通过编译选项改变默认位宽 <ul><li>Intel 编译器中设置浮点数默认位宽的编译选项： <ul><li><code>-r{8|16}</code> 设置字节数</li><li><code>-real-size &lt;size&gt;</code> 设置位宽，包括 32、64、128，可设置为 128 位(16 字节)</li><li><code>-autodouble</code> 设置为 64 位(8 字节)</li></ul></li><li>GNU 编译器中设置浮点数默认位宽的编译选项为 <code>-fdefault-real-8</code>，单精度浮点数默认位宽为 4 字节，双精度浮点数默认位宽为 8 字节，16 字节浮点数在旧版本不支持，新版本支持</li></ul></li></ul><h3 id="逻辑-logical-类型" tabindex="-1">逻辑 (logical) 类型 <a class="header-anchor" href="#逻辑-logical-类型" aria-label="Permalink to &quot;逻辑 (logical) 类型&quot;">​</a></h3><ul><li>Fortran 支持多种位宽的逻辑类型，位宽包括 1 字节、2 字节、4 字节、8 字节，但是逻辑判断只有两种结果：“是”（true）和“否”（false）。</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">整数位宽</th><th style="text-align:center;">Fortran 声明方式</th><th style="text-align:center;">C/C++ 声明方式</th></tr></thead><tbody><tr><td style="text-align:center;">1字节</td><td style="text-align:center;">logical*1；logical(kind=1)</td><td style="text-align:center;">bool</td></tr><tr><td style="text-align:center;">2字节</td><td style="text-align:center;">logical*2；logical(kind=2)</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">4字节</td><td style="text-align:center;">logical*4；logical(kind=4)</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">8字节</td><td style="text-align:center;">logical*8；logical(kind=8)</td><td style="text-align:center;"></td></tr></tbody></table><ul><li>当采用 logical 声明变量时，通常位宽默认为 4 字节，但可通过编译选项改变默认位宽，改变方法与整数相同</li></ul><h3 id="字符-character-类型" tabindex="-1">字符 (character) 类型 <a class="header-anchor" href="#字符-character-类型" aria-label="Permalink to &quot;字符 (character) 类型&quot;">​</a></h3><ul><li>只记录一个字母、符号时的数据类型称为“字符”，记录一连串的字符时，就称为“字符串”。一个字符占 1 个字节。</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">Fortran 声明方式</th><th style="text-align:center;">C/C++ 声明方式</th></tr></thead><tbody><tr><td style="text-align:center;">字符</td><td style="text-align:center;">character a<br>未赋值时，通常不能被打印出来</td><td style="text-align:center;">char a</td></tr><tr><td style="text-align:center;">字符串</td><td style="text-align:center;">character(len=10) a<br>未赋值时的默认字符是空格，字符串中的任意位置都可以是有效字符</td><td style="text-align:center;">char a[10]<br>字符串以首个 &#39;\\0&#39; 结束，通常必须含有至少一个 &#39;\\0&#39;</td></tr></tbody></table><ul><li>在 Fortran 中，char(0) 即 &#39;\\0&#39; 在打印时被忽略，但会被记录</li></ul><div class="language-Fortran vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Fortran</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">! char1.F90</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">program</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  implicit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> none</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ab&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cd&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  print</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,a , b, a, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;:end&#39;</span></span></code></pre></div><p>以下为编译输出过程</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gfortran</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> char1.f90</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Linux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./a.out</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Windows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.exe</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> start:abcd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  :end</span></span></code></pre></div><p>输出解释：字符 <code>a</code> 初始化时未被赋值，因而未被输出，而 char(0) 被忽略，但会被记录，这体现在长度为 10 字符的字符串 <code>b</code> 最终只有两个空格被输出，两个字符位被 <code>\\0 (即 char(0)) 填充</code></p><div class="language-Fortran vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Fortran</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">! char2.F90</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">program</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  implicit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> none</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) b</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  character</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) c</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39; &#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ab\\0cd&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  print</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,a , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b), , </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;:end&#39;</span></span></code></pre></div><blockquote><p>trim 命令用于去掉字符串后面的空格</p></blockquote><p>以下为编译输出过程</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gfortran</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> char2.f90</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Linux</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./a.out</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Windows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.exe</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> start:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ab</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> :end</span></span></code></pre></div><p>输出解释：<code>\\0</code> 不会被忽略，而是作为普通字符处理，原因在于 Fortran 没有转义字符，同时与字符 <code>a</code> 相比，<code>c</code> 作为字符串体现，因而其默认会被赋值为空格。</p><h2 id="数学表达式" tabindex="-1">数学表达式 <a class="header-anchor" href="#数学表达式" aria-label="Permalink to &quot;数学表达式&quot;">​</a></h2><ul><li>用 Fortran 来编写数学表达式的规则和方法都很“直观化”，和在纸上做的四则预算仅有少量差别，按照优先级从低到高顺序如下： <ul><li>+ 加法 - 减法</li><li>- 乘法 / 除法</li><li>*- 乘幂（两个星号要连续）</li><li>( ) 括号（表示括号起来的部分优先计算）</li></ul></li><li><strong>表达式中乘号不能省略</strong></li></ul><h3 id="混合精度计算" tabindex="-1">混合精度计算 <a class="header-anchor" href="#混合精度计算" aria-label="Permalink to &quot;混合精度计算&quot;">​</a></h3><ul><li>在计算过程中，按照等号右边操作数的最高精度进行计算，存在浮点操作数时，整数被转化为浮点数进行计算</li><li>将立即数（即运算式中的常数，与变量相区别）赋值给浮点变量时，可能因为溢出而发生四舍五入</li><li>在浮点计算过程中，四舍五入发生在等号右边的计算过程</li><li>浮点数到整数的类型转换过程中，直接舍弃小数位</li><li>C/C++ 也是上述规则</li></ul><hr><ul><li>浮点立即数默认为real类型，在赋值给双精度变量前可能发生四舍五入计算</li><li>双精度立即数由最后面的“d0”标记</li><li>C/C++ 没有上述情况</li></ul>`,52)]))}const o=i(l,[["render",n]]);export{g as __pageData,o as default};
