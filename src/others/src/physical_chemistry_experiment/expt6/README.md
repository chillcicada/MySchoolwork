# 数据处理概述

## 高分子链还原

结合周期性边界原理，考虑到最终的高分子链只需要高分子的绝对位置，因而实际上每个粒子在还原过程中只依赖与之键合的粒子和对应的平移量，一个简单的思路是从初始粒子开始，对之后的粒子进行步进检查，即将下一个粒子与当前粒子距离进行判定，超出 $r_c$ 即视作粒子进行了一次跨界，根据两粒子的方向矢对此后所有粒子坐标进行平移，进一步，由于实际上高分子链存在反复的跨界情况，而具体到每个粒子，其最终平移量是当前高分子链相对于原点（参考点）的平移状态乘以周期性边界距离（为定值），即引入一个平移数组来维护此平移状态即可，使用 $[x, y, z]$ 表示，规定 +1 为向正轴方向，反之为负，此时，只需要在判定位移是同时维护平移状态就可以在计算每个粒子时同时得到此时该粒子之后的高分子链的绝对位移状态（相对于参考系原点），进一步，由于高分子链可以视作更多高分子链的结合，而位移状态数组具有可加和性（因为如果参考系固定，最终绝对位移量也是固定的），即一个高分子链的还原可以被拆分成多个高分子链的还原和拼接，而不影响最终的高分子链的相对位置关系，这样处理的好处是各自段之间的运算互不干扰，具有高度的并行性，同时对于具有复杂分支结构的高分子链，在分支处断开可以将复杂的判断逻辑拆分为多个线性高分子链平移量的加和。

> 关于高分子链中数据结构的遐思

在此算法中，可以发现计算的关键处不在于之后的遍历，而在于高分子链的拆分（split），关于此，具体的数据结构变化为将邻接表（即拓扑结构）转化为树形结构维护，其中树根为节点，树叶为分支，保证每个树叶为单一线性分支。

> 更一般地，高分子链可以用图来维护，尤其是有环的情况（交联），不过由于此种情况太复杂了，加之我对环图的处理并不熟练，只能退而求其次依据写的高分子链的拓扑特性写了一份比较 messy 的代码，其逻辑如下：
>
> - 维护一个节点与所在链的映射表，当一个节点仅为枝叶（非端点）时，其索引长度必定为 1 （数据结构特性决定）
> - 因为需要维护多根节点的存在（邻接表插入时存在断裂点），维护所有的端点信息（包含根节点，叶节点和链尾点之外），其中根节点和尾节点比较特殊（因为环的存在，尾节点可以有多个索引），比较麻烦的是叶节点，其同时为链尾和链端，因而必定为分支点（多支结构），但实际上对于高分子而言，这二者是等效的，因而为了方便研究，我们假设支化高分子是存在方向的，一个枝叶的列表中，第一位为链端（近根节点侧），最后一位为链尾（远离根节点侧）
> - 插入节点时的判断，以 `a-b`为例：
>   - 如果 a 和 b 均不存在，直接创建新链；
>   - 如果 a 和 b 某一个存在，以 a 为例（最为常见的情况）：
>     - 如果 a 为叶节点或根节点，直接创建新链；
>     - 如果 a 为枝叶的中间节点，则以 a 为叶节点进行调整；
>     - 如果 a 为尾节点：
>       - 索引长度为 1 则进行延长；
>       - 索引长度大于 1 则创建新链
>   - 如果 a 和 b 同时存在：
>     - a 和 b 同为根节点：
>       - a 和 b 中存在至少一个为单枝结构，将其中一条单枝结构与另一节点相连；
>       - a 和 b 均存在多枝，创建新链，后者自动降级为叶节点。
>     - a 为根节点或叶节点，b为叶节点（反之同理），创建新链；
>     - a 为根节点或叶节点，b 为尾节点：
>       - b 仅有一个索引，将 b 所在分支倒置接在 a 上（此时如果 b 所在分支为孤枝，还需要对其端点进行降级）
>       - b 有多个索引：
>         - a 和 b 成环（同一树），新建链
>         - a 和 b 不成环（两个树），重建树，使其中只有一个根节点
>     - a 为根节点或叶节点，b 为枝叶中间节点，以 b 为叶节点进行调整
>     - a 和 b 同为中间节点，以 a 和 b 为叶节点进行调整
>     - a 为中间节点，b 为尾节点，以 a 为叶节点进行调整：
>       - b 仅有一个索引，将 b 所在分支倒置接在 a 上（此时如果 b 所在分支为孤枝，还需要对其端点进行降级）
>       - b 有多个索引：
>         - a 和 b 成环（同一树），新建链
>         - a 和 b 不成环（两个树），重建树，使其中只有一个根节点
>     - a 和 b 同为尾节点
>       - 此时 a 和 b 成环（同一树），则以其中一个为尾节点调整
>       - a 和 b 不成环（两个树），重建树，使其中只有一个根节点
>
> 实际上，由于设计的高分子链只有分支结构，因而写代码的时候直接偷懒了，代码摘要如下，具体代码实现参见附件。

```python
class Polymer:
  def __init__(self):
    self.chains = {}  # chain_id → list of nodes
    self.chain_counter = 0
    self.node_map = defaultdict(list)  # node → list of chain_ids
    self.endpoints = set()  # nodes that are endpoints of any chain
    pass

  def _add_chain(self, nodes):
    """add a linear chain with nodes"""
    pass

  def _remove_chain(self, chain_id):
    """remove a linear chain by chain id"""
    pass

  def is_endpoint(self, node):
    """whether the node is an endpoint"""
    pass

  def get_index_of_non_endpoint(self, node):
    """get index of a non endpoint, and assert len(cids) == 1"""
    pass

  def is_only_chain_start(self, node):
    """judge whether an endpoint is only the chain of chain"""
    pass

  def is_only_chain_end(self, node):
    """judge whether an endpoint is only the end of chain"""
    pass

  def add_relation(self, a, b):
	"""add `a-b` to Polymer"""
    pass

  def visualize(self):
    """print Polymer"""
    pass

  @classmethod
  def from_topology(cls, topology):
    """generate a Polymer from topology(a set of relation `a-b`)"""
    pass

  def export():
	"""export polymer as subchains"""
    pass
```

e.g.

```txt
// topology input
0-1,1-2,2-3,3-4,4-5,5-6,6-7,7-8,8-9,9-10,10-11,11-12,12-13,13-14,14-15,15-16,16-17,17-18,18-19,19-20,21-22,22-23,23-24,24-25,26-27,27-28,28-29,29-30,30-31,31-32,32-33,33-34,34-35,36-37,37-38,38-39,39-40,40-41,41-42,42-43,43-44,44-45,45-46,46-47,47-48,48-49,49-50,50-51,51-52,52-53,53-54,54-55,56-57,57-58,58-59,59-60,61-62,62-63,63-64,64-65,66-67,67-68,68-69,69-70,70-71,71-72,72-73,73-74,74-75,75-76,76-77,77-78,78-79,79-80,80-81,81-82,82-83,83-84,84-85,85-86,86-87,87-88,88-89,89-90,90-91,91-92,92-93,93-94,94-95,95-96,96-97,97-98,98-99,99-100,101-102,102-103,103-104,104-105,106-107,107-108,108-109,109-110,111-112,112-113,113-114,114-115,115-116,116-117,117-118,118-119,119-120,120-121,121-122,122-123,123-124,124-125,125-126,126-127,127-128,128-129,129-130,130-131,131-132,132-133,133-134,134-135,136-137,137-138,138-139,139-140,0-36,0-66,0-111,15-21,15-26,50-56,50-61,125-131,125-136,95-101,95-106
```

得到的输出如下：

```txt
unhandled case: 125, 131
Branch 1: 0-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15
Branch 2: 0-36-37-38-39-40-41-42-43-44-45-46-47-48-49-50
Branch 3: 0-66-67-68-69-70-71-72-73-74-75-76-77-78-79-80-81-82-83-84-85-86-87-88-89-90-91-92-93-94-95
Branch 4: 0-111-112-113-114-115-116-117-118-119-120-121-122-123-124-125
Branch 5: 15-16-17-18-19-20
Branch 6: 15-21-22-23-24-25
Branch 7: 15-26-27-28-29-30-31-32-33-34-35
Branch 8: 50-51-52-53-54-55
Branch 9: 50-56-57-58-59-60
Branch 10: 50-61-62-63-64-65
Branch 11: 95-96-97-98-99-100
Branch 12: 95-101-102-103-104-105
Branch 13: 95-106-107-108-109-110
Branch 14: 125-126-127-128-129-130-131-132-133-134-135
Branch 15: 125-136-137-138-139-140
```

> 这里的 125-131 大概是个意外，在原始代码中失误加上了一个小环😥😥，因而实际的高分子链切分为（经过手动调整）：

```txt
Branch 1: 0-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15
Branch 2: 0-36-37-38-39-40-41-42-43-44-45-46-47-48-49-50
Branch 3: 0-66-67-68-69-70-71-72-73-74-75-76-77-78-79-80-81-82-83-84-85-86-87-88-89-90-91-92-93-94-95
Branch 4: 0-111-112-113-114-115-116-117-118-119-120-121-122-123-124-125
Branch 5: 15-16-17-18-19-20
Branch 6: 15-21-22-23-24-25
Branch 7: 15-26-27-28-29-30-31-32-33-34-35
Branch 8: 50-51-52-53-54-55
Branch 9: 50-56-57-58-59-60
Branch 10: 50-61-62-63-64-65
Branch 11: 95-96-97-98-99-100
Branch 12: 95-101-102-103-104-105
Branch 13: 95-106-107-108-109-110
Branch 14: 125-126-127-128-129-130-131
Branch 15: 125-131
Branch 16: 125-136-137-138-139-140
Branch 17: 131-132-133-134-135
```

---

高分子链段还原及其实现：

